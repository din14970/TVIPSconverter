* self._readIndividualFile(fn, part) should not return anything.
 now it is returning headers and frames:

 # merge memory efficient
 self.frames = np.asarray(frames)
 self.frameHeader.extend(headers)

 or

 if (part == 0):
     self.frames = np.asarray(frames)
 else:
     self.frames = np.append(self.frames, frames, axis=0)

 self.frameHeader.extend(headers)



     # if (opts.rotator):
     #     previous = 0x43  # some unlikely initial value
     #     start = None
     #     end = None
     #     i = 0
     #     numframes = None
     #     if opts.dimension is not None:
     #         xdim, ydim = list(map(int, opts.dimension.split('x')))
     #         numframes = xdim*ydim
     #     for i, fh in enumerate(rec.frameHeader):
     #         logger.debug("Frame: {:05d} Index: {:05d}".format(i, fh['rotidx']))
     #         # set start idx
     #         if start is None and end is None:
     #             if fh['rotidx'] == previous + 1:  # first consecutive frame idx
     #                 start = i - 1  # TODO: check for > 0
     #                 logger.info("Found start at {}".format(start))
     #                 continue
     #
     #         if start is not None:
     #             if numframes is None:
     #                 # find end idx
     #                 if fh['rotidx'] == previous:
     #                     break
     #             else:
     #                 logger.info("Taking {} frames based on given "
     #                             "dimensions".format(numframes))
     #                 # manipulate i, not end as it will be assigned outside loop
     #                 i = start + numframes
     #                 logger.debug("Start: {:05d} End: {:05d}".format(start, i))
     #                 if (len(rec.frameHeader) <= i):
     #                     logger.error("Too few records in dataset for the "
     #                                  "given dimensions")
     #                 break
     #         previous = fh['rotidx']
     #     end = i
     #     logger.info("Found end at {}".format(end))
     #     # remove uninteresting data
     #     rec.frames = rec.frames[start:end]
     #     rec.frameHeader = rec.frameHeader[start:end]
     #     logger.info("Found {} frames in set".format(len(rec.frames)))
         # rec.frames = np.asarray(rec.frames)
         # rec.frameHeader = np.asarray(rec.frameHeader)
